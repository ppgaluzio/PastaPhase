\documentclass[11pt]{article}

\usepackage[dvipsnames]{xcolor}

\definecolor{light-gray}{gray}{0.95}
%\def\code#1{\texttt{#1}}
%\newcommand{\code}[1]{$#1$} 
\newcommand{\code}[1]{\colorbox{light-gray}{\mbox{\texttt{#1}}}}
\newcommand{\bash}[1]{\colorbox{light-gray}{\mbox{\$ \texttt{#1}}}}

\begin{document}

\title{Codes for the nuclear equation of state meta-modeling, neutron star EOS, TOV solver}
\author{J. Margueron}
\date{\today}
\maketitle

These notes describe the use of the different codes associated to the nuclear meta-modeling of dense matter~\cite{Margueron2018a,Margueron2018b}. There are three different codes described here:
\begin{enumerate}
\item \code{metaEosMain.f95}: this code takes as inputs the empirical parameters and generates the dense matter EOS.
\item \code{nsEosMain.f95}: this code merges together a crust EOS with the meta-modeling for the core of the neutron star generated by \code{metaEosT0.f95}.
\item \code{tovMain.f95}: this code solves the TOV equations for a given EOS generated by \code{nsEosMain.f95}.
\end{enumerate}

The interface between these codes is done in the main body of each of them. For instance \code{nsEosMain.f95} call the routines from \code{metaEosMain.f95} to generate the core EOS, and \code{tovMain.f95} calls the routines from \code{metaEosMain.f95}  and
\code{nsEosMain.f95}. They can therefore run independently from each other.


\section{Meta-model for the nuclear equation of state}
\label{sec:metaEOS}

This part describes the code which generates the metaEOS, taking as input the values of the empirical parameters.

Compile: \bash{bash compile-metaEos.sh}

Run: \bash{./metaEos.e \{args\}}

The arguments \code{\{args\}} can be:
\begin{enumerate}
\item[-] void: in this case, the code reads the default values defined in the file \code{metaEos.in}.
\item[-] the list of 13 values of the empirical parameters written as integers. See for instance  \code{metaEos.in}.
\end{enumerate}

It calls the main code \code{metaEosMain.f95} and the module  \code{metaEosT0.f95}.

\subsection{\code{metaEosMain.f95}}

The code metaEOSMain.f95 is the main part of the code.
It calls 3 subroutines:
\begin{enumerate}
\item[$\bullet$] \code{call metaEos\_read\_inputs(coef)},
\item[$\bullet$] \code{call metaEos\_compute\_T0\_SM\_NM(coef)},
\item[$\bullet$] \code{call metaEos\_compute\_T0\_beta(coef)}.
\end{enumerate}

These subroutines are defined in the module \code{metaEosT0.f95}.

\subsection{\code{metaEosT0Type.f95}}

Define here the global parameters and the typed variables.

Note that you can choose the verbose mode (a lots of information on the standard output) or the non-verbose mode (information reduced to its minumum). 

The global parameters are:
\begin{enumerate}
\item[$\bullet$] \code{metaEos\_neparam=15}: number of parameters of the model (=15). There are 13 empirical parameters plus \code{ikin} and \code{imuon}. The 13 empirical parameters are: $E_{sat}$, $n_{sat}$, $K_{sat}$, $Q_{sat}$, $Z_{sat}$, $E_{sym}$, $L_{sym}$, $K_{sym}$, $Q_{sym}$, $Z_{sym}$, $m^*_{sat}$, $\Delta m^*_{sat}$, $b$; and the two parameters control: \code{ikin=0(1)} empirical model without (with) kinetic energy, \code{imuon=0(1)} EOS without (with) muons. 
\item[$\bullet$] \code{metaEos\_lverb=.true./.false.}: switch from verbose to non-verbose mode.
\end{enumerate}

The typed variables are:
\begin{enumerate}
\item[$\bullet$] \code{metaEos\_Empirical}: \code{param(0:1,0:4)}, \code{nsat}, \code{ms}, \code{dm}, \code{xb}, \code{ikin}, \code{imuon}.
\item[$\bullet$] \code{metaEos\_Coef}: \code{VCOEF(0:1,0:4)}, \code{nsat}, \code{ms}, \code{dm}, \code{xb}, \code{ikin}, \code{imuon}, ...
\item[$\bullet$] \code{metaEos\_Densities}:
\item[$\bullet$] \code{metaEos\_Baryons}:
\item[$\bullet$] \code{metaEos\_Leptons}:
\item[$\bullet$] \code{metaEos\_Photons}:
\item[$\bullet$] \code{metaEos\_All}:
\end{enumerate}

\subsection{\code{metaEosT0.f95}}

The important subroutines are described here:
\begin{enumerate}
\item[$\bullet$] \code{metaEos\_read\_inputs(coef)}: Reads the input in different ways, depending on the arguments  \code{\{args\}} of the code.
The arguments are integer numbers defined between 0 and $\pm$ 9999, according to the following conversion:\\
$E_{sat}$:  \code{emp\%param(0,0) =-0.01   * eparam(1)}. Ex: 1600 (-16.00 MeV)\\
$n_{sat}$:  \code{emp\%nsat       = 0.0001 * eparam(2)}. Ex: 1600 (0.1600 fm$^{-3}$)\\
$K_{sat}$:  \code{emp\%param(0,2) = 0.1    * eparam(3)}. Ex: 2350 (235.0 MeV)\\
$Q_{sat}$:  \code{emp\%param(0,3) = 0.1    * eparam(4)}. Ex: 5000 (500.0 MeV)\\
$Z_{sat}$:  \code{emp\%param(0,4) = 1.0    * eparam(5)}. Ex: -5000 (-5000 MeV)\\
$E_{sym}$:  \code{emp\%param(1,0) = 0.01   * eparam(6)}. Ex: 3000 (30.00 MeV)\\
$L_{sym}$  \code{emp\%param(1,1) = 0.01   * eparam(7)}. Ex: 4000 (40.00 MeV)\\
$K_{sym}$  \code{emp\%param(1,2) = 0.1    * eparam(8)}. Ex: -1000 (-100.0 MeV)\\
$Q_{sym}$  \code{emp\%param(1,3) = 1.0    * eparam(9)}. Ex: 1000 (1000 MeV)\\
$Z_{sym}$  \code{emp\%param(1,4) = 1.0    * eparam(10)}. Ex: 7000 (7000 MeV)\\
$m^*_{sat}$  \code{emp\%ms         = 0.0001 * eparam(11)}. Ex: 7500 (0.7500)\\
$\Delta m^*_{sat}$  \code{emp\%dm         = 0.0001 * eparam(12)}. Ex: 1000 (0.1000)\\
$b$:  \code{emp\%xb         = 0.01   * eparam(13) }. Ex: 690 (6.90)\\
In addition, there are two addition parameters \code{ikin=0/1} and \code{imuon=0/1}.\\
Once the inputs are read: \code{call metaeos\_setup\_coeff(emp,coef)} to convert the empirical parameters in \code{emp} into the model coefficients in \code{coef}.
\item[$\bullet$] \code{call metaeos\_compute\_T0\_SM\_NM(coef)}: compute the EOS in symmetric matter (SM) and neutron matter (NM). The lofical variable \code{iopt\_beta=.false./.true.} optimizes (or not) the code for beta-equilibrium search.
\begin{enumerate}
\item[$-$] \code{call metaeos\_T0\_densities(den,xd,xmuon,coef,eosDen)}: sets the densities of the particles for a given choice for \code{xd} and \code{xmuon=0}.
\item[$-$] \code{call metaeos\_T0\_baryons(coef,eosDen,iopt\_beta,eosb0)}: calculates the baryon contribution to the EOS. Note that the meta-model is defined here. For more details go to Refs.~\cite{Margueron2018a,Margueron2018b}.
\end{enumerate}
Print results on standard output.
\item[$\bullet$] \code{call metaeos\_compute\_T0\_beta(coef)}: compute the EOS at beta equilibrium, considering neutrons, protons, electrons and muons. For a faster code, muons can be neglected by setting \code{coef\%imuon=0} in the input file.
\begin{enumerate}
\item[$-$] if \code{coef\%imuon=0}: \code{call metaeos\_T0\_beta\_npe(den,xd,xmuon,coef,eosDen)}: calculates the EOS for n, p, and e matter (without $\mu$).
\item[$-$] if \code{coef\%imuon=1}: \code{call metaeos\_T0\_beta\_npemuon(den,xd,xmuon,coef,eosDen)}: calculates the EOS for n, p, e, and $\mu$.
%\item[$-$] \code{call metaeos\_T0\_densities(den,xd,xmuon,coef,eosDen)}:
\item[$-$] \code{call metaeos\_T0\_baryons(coef,eosDen,iopt\_beta,eosb0)}: calculates the baryon contribution to the EOS. Note that the meta-model is defined here. For more details go to Refs.~\cite{Margueron2018a,Margueron2018b}.
\item[$-$] \code{call metaeos\_T0\_leptons(eosDen,iopt\_beta,eosl0)}: calculates the lepton contribution to the EOS (to be checked).
\item[$-$] \code{call metaeos\_T0\_photons(eosDen,iopt\_beta,eosp0)}: calculates the photon contribution to the EOS (to be done).
\item[$-$] \code{call metaeos\_T0\_all(coef,eosDen,iopt\_beta,eosb0,eosl0,eosp0,eosa0)}: sums up the contribution of all particles (to be checked).
\end{enumerate}
\end{enumerate}





\section{Neutron star equation of state}
\label{sec:nsEOS}

This part describes the code which generates the neutron star EOS -- connect the core EOS with a crust EOS --
taking as input the values of the empirical parameters and the parameters for the crust EOS.

Compile: \bash{bash compile-nsEos.sh}

Run: \bash{./nsEos.e \{args\}}

The arguments \code{\{args\}} can be:
\begin{enumerate}
\item[-] void or the list of 15 values of the empirical parameters written as integers: in this case, the parameters for the crust EOS are explicitly written in the subroutine. To modify them, edit the subroutine \code{nsEos\_read\_inputs} defined in \code{nsEosMod.f95}
\item[-] one argument defining the name of the input file, such as for instance \code{nsEos.in}, where the parameters of the crust EOS are defined.
\end{enumerate}

It calls the main code \code{nsEosMain.f95} and the module  \code{nsEosMod.f95}.

\subsection{\code{nsEosMain.f95}}

The code nsEOSMain.f95 is the main part of the code.
It calls 4 subroutines:
\begin{enumerate}
\item[$\bullet$] \code{call nsEos\_read\_inputs(nsEos\_inp)}: reads the input parameters for the nsEos code,
\item[$\bullet$] if \code{nsEOS\_inp\%core="meos"}: \code{call metaEos\_read\_inputs(coef\_meta)}: reads the input parameters for the meta-model,
\item[$\bullet$] if \code{nsEOS\_inp\%core="poly"}: \code{call polyEos\_read\_inputs(coef\_poly)}: reads the input parameters for the piecewise polytrope,
\item[$\bullet$] \code{call nsEos\_compute\_eos(coef\_meta,coef\_poly,nsEos\_inp,nseos)}: join together the crust and the core EOS,
\item[$\bullet$] \code{call nsEos\_write\_eos(nseos)}: write results in folder \code{nsEos-res/}.
\item[$\bullet$] \code{call nsEos\_write\_table\_eos(nseos,coef\_meta)}: write table in folder \code{nsEos-res/} for NS merger models.
\end{enumerate}


\subsection{\code{nsEosType.f95}}

Define here the global parameters and the typed variables.

Note that you can choose the verbose mode (a lots of information on the standard output) or the non-verbose mode (information reduced to its minumum). 

The global parameters are:
\begin{enumerate}
\item[$\bullet$] \code{nsEos\_ncrust=200}: number of density point for the crust EOS.
\item[$\bullet$] \code{nsEos\_ncore=200}: number of density point for the core EOS.
\item[$\bullet$] \code{nsEos\_neos=nsEos\_ncrust+nsEos\_ncore}: number of density point for the crust+core EOS.
\item[$\bullet$] \code{nsEos\_lverb=.true./.false.}: switch from verbose to non-verbose mode.
\item[$\bullet$] \code{nsEos\_lfast=.true./.false.}: switch from fast to slower mode (fast to be completed).
\end{enumerate}

The typed variables are:
\begin{enumerate}
\item[$\bullet$] \code{nsEos\_inputs}: input parameters.
\item[$\bullet$] \code{nsEos\_crust}: crust quantities.
\item[$\bullet$] \code{nsEos\_core}: core quantities.
\item[$\bullet$] \code{nsEos\_eos}: crust+core quantities.
\end{enumerate}

Note that the \code{crust}, \code{core} and \code{eos} typed variables have each the following array: \code{EosLog(i,iden)} where 
\begin{enumerate}
\item[$\bullet$] $i=1$: $\log(n_b)$, \code{$10^{eos\%EosLog(1,iden)}$} is the baryon density in fm$^{-3}$.
\item[$\bullet$] $i=2$: $\log(\rho)$, \code{$10^{eos\%EosLog(2,iden)}$} is the energy density in g.cm$^{-3}$.
\item[$\bullet$] $i=3$: $\log(P)$, \code{$10^{eos\%EosLog(3,iden)}$} is the pressure in dyn.cm$^{-2}$.
\item[$\bullet$] $i=4$: $(v_c/c)^2$, \code{$eos\%EosLog(4,iden)$} is the sound velocity.
\end{enumerate}


\subsection{\code{nsEosMod.f95}}

The important subroutines are described here.\\
\begin{enumerate}
\item[$\bullet$] \code{call nsEos\_read\_inputs(nsEos\_inp)}: Reads the input in different ways, depending on the arguments  \code{\{args\}} of the code. These parameters are explained hereafter.\\
\begin{enumerate}
\item[$-$] \code{nsEos\_inp\%crust}: name of the file (stored in \code{nstar-EosCrut/}) where the crust EOS is given (table). it can be \code{"sly.dat"} or \code{"fps.dat"}, or ...\\
\item[$-$] \code{nsEos\_inp\%core}: kind of EOS for the core. It can be the metaEOS (\code{"meos"}) or a polytropic form (not yet implemented). \\
\item[$-$] \code{nsEos\_inp\%dobeta}: Type of equations to solve the $\beta$-equilibrium. By default keep it to be 3 (solves the chemical potential equation). The value 1 solves the approximate equation based on the symmetry energy.\\
\item[$-$] \code{nsEos\_inp\%temp}: set it to 0.d0. This code does not works yet at finite temperature.\\
\item[$-$] \code{nsEos\_inp\%den\_core\_min}: minimal density for the core EOS (in units of $n_{sat}$).\\
\item[$-$] \code{nsEos\_inp\%den\_core\_max}: maximal density for the core EOS (in units of $n_{sat}$).\\
\item[$-$] \code{nsEos\_inp\%den\_core\_step}: step density for the core EOS (in units of $n_{sat}$).\\
\end{enumerate}
\item[$\bullet$] \code{call metaEos\_read\_inputs(coef\_meta)}: see Sec.~\ref{sec:metaEOS}. 
\item[$\bullet$] \code{call nsEos\_compute\_eos(coef\_meta,coef\_poly,nsEos\_inp,nseos)}: This subroutine computes the metaEOS for the core equation of state, see Sec.~\ref{sec:metaEOS}, and matches it to the crust EOS.
Notice that by default, the core EOS without muon is calculated here. to switch to an EOS with muons, comment line 524 and uncomment line 520.
This subroutine calls the following subroutines:
\begin{enumerate}
\item[$-$] \code{call nsEos\_compute\_crust(crust)}: store the crust EOS into \code{crust\%EosLog(i,iden)}, where: 
\begin{enumerate}
\item[$*$] $i=1$ stores $\log_{10} n$ in (fm$^{-3}$), 
\item[$*$] $i=2$ stores $\log_{10} \rho$ in (g.cm$^{-3}$), 
\item[$*$] $i=3$ stores $\log_{10} P$ in (dyn.cm$^{-2}$), 
\item[$*$] $i=4$ stores $(v_s/c)^2$.
\end{enumerate}
\item[$-$] \code{call nsEos\_compute\_core\_metaEos(core)}: store the core EOS from the metamodeling into \code{core\%EosLog(i,iden)}. At the exit of the loop density, tells if stability/causality is fulfilled/violated. The max density (stored in \code{core\%den\_max}) is defined as the first density for which either one or the other of these conditions are violated.
\item[$-$] \code{call nsEos\_compute\_core\_polyEos(core)}: store the core EOS from the piecewise polytropes into \code{core\%EosLog(i,iden)} (to be implemented).
\item[$-$] \code{call nsEos\_match\_eos(eos)}: combine crust and core EOS into \code{eos\%EosLog(i,iden)}.
\end{enumerate}
\item[$\bullet$] \code{call nsEos\_write\_eos(nseos)}: write the neutron star EOS into different files 
\begin{enumerate}
\item[$-$] \code{nsEos-res/eos.out}: the same data as the one used by the code TOV, 
\item[$-$] \code{nsEos-res/eos-lin.out}: a linear interpolation of the EOS -- mostly for the high density core EOS, 
\item[$-$] \code{nsEos-res/eos-log.out}: a log interpolation of the EOS.
\end{enumerate}
These files store the results by columns in the following order: $n$ in (fm$^{-3}$), $\rho$ in (g.cm$^{-3}$), $P$ in (dyn.cm$^{-2}$), and $(v_s/c)^2$.
\item[$\bullet$] \code{call nsEos\_write\_table\_eos(nseos,coef\_meta)}: write the neutron star EOS into a table for the NS merger simulation:
\begin{enumerate}
\item[$-$] \code{nsEos-res/table.out}: a log interpolation of the EOS as defined for the NS merger simulation
\end{enumerate}
This file stores the results by columns in the following order: density index $i$, $n$ in (fm$^{-3}$), $\rho$ in (g.cm$^{-3}$), $P$ in (dyn.cm$^{-2}$), and $(v_s/c)^2$.
The head of the file contains the meta-model parameters and some crust information.
\end{enumerate}







\section{Solver for the TOV equations}
\label{sec:tov}

This part describes the code which solves the TOV equations, based on the neutron star equation of state previously generated.

Compile: \bash{bash compile-tov.sh}

Run: \bash{./tov.e \{args\}}

The arguments \code{\{args\}} can be:
\begin{enumerate}
\item[-] void or the list of 15 values of the empirical parameters written as integers: in this case, the parameters for TOV solver are explicitly written in the subroutine. To modify them, edit the subroutine \code{tov\_read\_inputs} defined in \code{tovMod.f95} 
\item[-] 2 arguments: these arguments define the name of the input files containing the parameters for the nsEos code and the TOV solver, for instance \code{nsEos.in tov.in}.
\end{enumerate}

It calls the main code \code{tovMain.f95} and the module  \code{tovMod.f95}.

\subsection{\code{tovMain.f95}}

The code tovMain.f95 is the main part of the code.
It calls 4 subroutines:
\begin{enumerate}
\item[$\bullet$] Build the EOS (same as in nsEosMain.f95):
\begin{enumerate}
\item[$-$] \code{call nsEos\_read\_inputs(nsEos\_inp)}: reads the input parameters for the nsEos code,
\item[$-$] if \code{nsEOS\_inp\%core="meos"}: \code{call metaEos\_read\_inputs(coef\_meta)}: reads the input parameters for the meta-model,
\item[$-$] if \code{nsEOS\_inp\%core="poly"}: \code{call polyEos\_read\_inputs(coef\_poly)}: reads the input parameters for the piecewise polytrope,
\item[$-$] \code{call nsEos\_compute\_eos(coef\_meta,coef\_poly,nsEos\_inp,nseos)}: join together the crust and the core EOS,
\item[$-$] \code{call nsEos\_write\_eos(nseos)}: write results in folder \code{nsEos-res/}.
\end{enumerate}
\item[$\bullet$] Solves the TOV equations: 
\begin{enumerate}
\item[$-$] \code{tov\_read\_inputs(tov\_inp)}: reads the input parameters for the tov code,
\item[$-$] \code{tov\_write\_eos(tov\_eos)}: write EOS in folder \code{tov-res/}, 
\item[$-$] stop here if \code{tov\%do\_tov="no"}, otherwise proceed.
\item[$-$] if \code{tov\%nbc$\ne$0}: \code{tov\_solve(tov\_inp,tov\_eos)}. Solves the TOV eqs for the central density defined in variable  \code{tov\%nbc}.
\item[$-$] if \code{tov\%nbc$=$0}: \code{tov\_solve\_loopden(tov\_inp,tov\_eos)}. Solves the TOV eqs for a set of densities starting from 0.1~fm$^{-3}$ up to the maximal density, with step \code{CST\_nsat/30.0}.
\end{enumerate}
\end{enumerate}


\subsection{\code{tovType.f95}}

Define here the global parameters and the typed variables.

Note that you can choose the verbose mode (a lots of information on the standard output) or the non-verbose mode (information reduced to its minumum). 

The global parameters are:
\begin{enumerate}
\item[$\bullet$] \code{tov\_nrad=10000}: number of points for the radial integration.
\item[$\bullet$] \code{tov\_neos=400}: number of density-points for the EOS.
\item[$\bullet$] \code{tov\_lverb=.true./.false.}: switch from verbose to non-verbose mode.
\item[$\bullet$] \code{tov\_lfast=.true./.false.}: switch from fast to slower mode (fast to be completed).
\end{enumerate}

The typed variables are:
\begin{enumerate}
\item[$\bullet$] \code{TY\_TOV\_inputs}: input parameters.
\item[$\bullet$] \code{TY\_TOV\_eos}: crust+core quantities.
\item[$\bullet$] \code{TY\_TOV\_outputs}: output results.
\item[$\bullet$] \code{TY\_TOV\_outputs\_rot}: output results for the slow rotation case.
\item[$\bullet$] \code{TY\_TOV\_outputs\_tidal}: output results for the tidal deformability.
\end{enumerate}



\subsection{\code{tovMod.f95}}

The important subroutines are described here.\\

\code{call tov\_read\_inputs(tov\_inp)}: Reads the input in different ways, depending on the arguments  \code{\{args\}} of the code. These parameters are explained hereafter.\\
\code{tov\_inp\%do\_tov}: "yes" or "no". Decide to run or not the TOV solver, after the construction of the EOS (ex: "yes").\\
\code{tov\_inp\%dradmax}, \code{tov\_inp\%dradmin}: Adaptative mesh in the radial integration of the TOV equations. maximal and minimal step in unit of the Schwarzschild radius for the sun (ex: 1.d-1, 3.d-4).\\
\code{tov\_inp\%brad}: maximal value in the radial integration, in cm (ex: 30.d5, 30 km).\\
\code{tov\_inp\%nbc}: central baryon density for the TOV solver, in fm$^{-3}$. If set to 0, then loop over different values for the central density (ex: 0).\\
\code{tov\_inp\%nbexit}: run TOV solver only if the metaEOS is stable and causal up to this density, defined in units of $n_{sat}$ (ex: 2.5).\\
\code{tov\_inp\%pressMin}: minimal pressure below which the solver is stopped and where the radius is defined, in dyn/cm2 (ex:1.d10).\\
\code{tov\_inp\%aom0}: $\Omega_0$ for the calculation of the moment of inertia (ex: 1.d-8).




\begin{thebibliography}{99}
\bibitem{Margueron2018a} J. Margueron, R. Casali, and F. Gulminelli, Phys. Rev. C 96, 065805 (2018).
\bibitem{Margueron2018b} J. Margueron, R. Casali, and F. Gulminelli, Phys. Rev. C 96, 065806 (2018).
\bibitem{Piekarewicz2009} J. Piekarewicz and M. Centelles, Phys. Rev. C 79, 054311 (2009).
%\bibitem{Ducoin2011} C. Ducoin, J. Margueron, C. Provid\^encia, and I. Vida\~na, Phys.Rev. C 83, 045810 (2011).
%\bibitem{Tews2018} I. Tews, J. Margueron, and S. Reddy, arXiv: 1804.02783 (nucl-th).
%\bibitem{Tews2016} I. Tews, S. Gandolfi, A. Gezerlis, A. Schwenk, Phys. Rev. C 93, 024305 (2016).
\end{thebibliography}





\end{document}
